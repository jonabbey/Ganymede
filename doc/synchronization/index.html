<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../stylesheets/ganymede.css"/>
    <title>Ganymede Synchronization Guide</title>
  </head>

  <body>
    <div id="header">
      <img src="../gifs/ganymede_title.gif" alt="Ganymede Logo"/>

      <div id="title">
        <h1>Ganymede 2.0 Sync Channel Guide</h1>
        <p>Release 2.0 - 22 November 2010</p>
      </div>

      <div id="abstract">
        <p>This document is intended to be a comprehensive guide to
        implementing data synchronization from Ganymede to your target
        directory services, using the new Ganymede 2.0 Sync Channel
        mechanism.  This guide covers neither importing data
        <b>into</b> Ganymede (see the <a
        href="../xml/index.html">Ganymede XML Guide</a> for that), nor
        the use of the older and more tricky Ganymede 1.0
        synchronization system.  For the latter, consult the <a
        href="ganymedebuildertask.html">GanymedeBuilderTask
        Synchronization Guide</a>.</p>

        <p>This guide likewise assumes that you already know enough
        about the Ganymede data model to configure a Ganymede schema
        that is capable of containing and modeling the directory
        services data that you want to manage with Ganymede.  If this
        is not the case, you might want to read the <a
        href="../xml/schema.html">Ganymede XML Schema</a> document for
        some details on how a Ganymede schema is specified.</p>
      </div>

      <p>By <a href="mailto:jonabbey@arlut.utexas.edu">Jonathan Abbey</a></p>
    </div>

    <h2>1. Approaches to Synchronization</h2>

    <p>Ganymede is designed around a transactional model, in which a
    set of changes that transition the Ganymede server from one
    consistent state to another is processed as a single unit of work.
    As such, the transaction is both the minimum unit of change for
    Ganymede and the trigger that causes the Ganymede server to
    synchronize its data to target directory services.</p>

    <p>Given this, there are in principle two ways that Ganymede might
    handle synchronizing data to the services that it feeds:</p>

    <ol>
      <li>Dump out everything it knows relevant to the
      synchronization and arrange for that 'full state' information
      to completely replace the previous state of the external
      managed services.</li>

      <li>Just send out relevant information that has changed since
      the last synchronization.</li>
    </ol>

    <p>Directory services like NIS and DNS have traditionally required
    a 'full state' build system, as those services originally provided
    no mechanism for applying incremental changes to their
    configuration.  Modern directory services like LDAP, on the other
    hand, explicitly support incremental change commands.  Applying
    changes to these kinds of directories works most efficiently when
    a small list of recent changes ("deltas") can be provided.</p>

    <p>These two synchronization styles each have their own strengths
    and weaknesses.</p>

    <h3 id="describing_full_state">Full State Synchronization</h3>

    <p>With a full state synchronization, it really doesn't matter
    whether any previous synchronizations were successful or not,
    because each synchronization will contain a complete description
    of the desired configuration for the target service.  This means
    that missing a synchronization (perhaps because the target
    directory service is temporarily unavailable) is no problem.  The
    target directory will just catch up the next time a
    synchronization occurs.  The inherent redundancy of this approach
    can make the synchronization process very robust, but the downside
    is that a full state synchronization can be time consuming.</p>

    <p>In addition, if it isn't possible to efficiently wipe and
    reload the target directory service, a process of comparison must
    be undertaken to calculate what has changed between the data
    written out for the synchronization and the pre-existing
    configuration of the target directory service.  In some cases it
    may not even be possible to read the pre-existing data from the
    target directory service in order to be able to detect what has
    changed.  This is the case of <code class="type">unicodePwd</code>
    in Active Directory, for instance, which is a write-only field.
    Not being able properly to compare the full state data with the
    contents of the target service may mean that more changes will
    have to be sent to the target than would be necessary with a true
    incremental synchronization.</p>

    <h3 id="describing_incremental">Incremental Synchronization</h3>

    <p>Synchronizing only the recently applied transactions can be far
    more efficient, assuming the target directory service can accept
    and apply a set of changes.  Only a very small amount of data may
    need to be synchronized at each synchronization, and it's not
    necessary for the target directory service to erase or reload
    anything other than what actually changed.</p>

    <p>This kind of "delta" synchronization, however, has some severe
    shortcomings.  The first problem is that if we are only sending
    the most recent transactions, we must absolutely rely on the
    target directory service to remember all previous changes.  If a
    transaction were to get lost somehow, the target directory service
    would become out of sync with the master data held in Ganymede,
    and later synchronizations might never detect or fix the problem.</p>

    <p>Another problem is that if we limit the amount of data we send
    to the synchronization channel to only that which recently
    changed, we might fail to provide enough surrounding context to
    allow the synchronization system to translate the synchronization
    data into a form suitable to the target directory service.  It
    wouldn't do, for example, to try and write to a synchronization
    channel the fact that a user's password changed without also
    including enough surrounding context to allow the synchronization
    system to locate the user record to be changed in the target
    service.</p>

    <div class="note">
      <p>Ganymede supports both full state and incremental
      synchronization to target data services.  Which of the two
      you'll want to use will depend on the type of directory service
      you're wanting to synchronize to, the size of your data set, the
      frequency with which it will change, and the confidence you have
      as to how reliable your target directory service is.  The more
      reliable your target directory service, the larger your data
      set, and the more frequent your synchronizations, the more an
      incremental style may be appropriate for you.</p>

      <p>Contrariwise, if your target directory service is not
      reliable enough to always retain changes that are passed to it
      from Ganymede (either because the target service lost data or
      because individual changes were refused due to tight or even
      unpredictable integrity constraints on the target service), you
      may want to stick with a slower but more redundant full state
      synchronization approach.</p>
    </div>

    <h2 id="options">2. Ganymede Synchronization</h2>

    <p>Whether incremental or full state, all Ganymede synchronization
    is organized around a two step process.  In the first step, the
    Ganymede server writes files containing synchronization data. In
    the second step, an external, free-standing program is run to read
    in these data files and do whatever may be required to transmit
    the synchronization information to target services.  This division
    of labor between the Ganymede server and your external code allows
    for a great degree of flexibility in implementing the
    synchronization logic, without requiring extensive code
    development and maintenance within the Ganymede server itself.</p>

    <div class="note">
    <p>Originally, implementing the first step of this process
    required subclassing the <a
    href="../javadoc/arlut/csd/ganymede/server/GanymedeBuilderTask.html">arlut.csd.ganymede.server.GanymedeBuilderTask</a>
    class in the Ganymede server and writing custom Java code to scan
    the portions of the Ganymede data store relevant to a specific
    synchronization task and to write out custom-formatted data files.
    This approach required the adopter to get intimately familiar with
    the complex internal Ganymede <a
    href="../javadoc/arlut/csd/ganymede/server/DBStore.html">DBStore</a>
    APIs for examining data in the Ganymede server.  Not an easy thing
    to do (or to document), and the necessity of recompiling Java code
    and stopping and restarting the Ganymede server made things more
    difficult.</p>

    <p>We still support (and ourselves rely on) the
    GanymedeBuilderTask synchronization infrastructure, but we don't
    want to emphasize its use for new adopters of Ganymede.  If you're
    interested in reading about the advantages of the older sync
    model, please consult the <a
    href="ganymedebuildertask.html">GanymedeBuilderTask
    Synchronization Guide</a> for details.</p>
    </div>

    <p>With Ganymede 2.0, we introduce a new synchronization
    infrastructure built around a new Ganymede construct, the <code
    class="type">Sync Channel</code>.  Sync Channel synchronization
    allows you to configure synchronization in the Ganymede server
    using nothing but the Ganymede GUI client and/or the Ganymede <a
    href="../xml/xmlclient.html">xmlclient</a>.  Sync Channels don't
    require you to write any Java code.. once configured, the first
    step of synchronization (writing out data files) is handled
    automatically by the Ganymede server using a standardized XML file
    format.</p>

    <h2 id="sync_channels">3. Sync Channels</h2>

    <p>A <code class="type">Sync Channel</code> is a type of object in
    the Ganymede data store.  You create and edit them in order to
    configure XML-based synchronization channels in the Ganymede
    server.</p>

    <p>Sync Channels come in three flavors, according to the style of
    synchronization they are configured to support:</p>

    <ul>
      <li>Automatic Full State</li>
      <li>Automatic Incremental</li>
      <li>Manual</li>
    </ul>

    <p><code class="type">Automatic Full State</code> sync channels
    represent automatically scheduled, full state builds.  A full
    state sync channel causes the Ganymede server to schedule a
    synchronization as soon as possible after a transaction is
    committed.  When a synchronization is run, the Ganymede server's
    data store is locked against commits while a full-state XML file
    is written.  After the file is written, the data store is unlocked
    and the external build process is run on the full-state XML
    file.</p>

    <p><code class="type">Automatic Incremental</code> sync channels
    represent automatically scheduled, transaction-by-transaction
    incremental builds.  With this sort of sync channel, transactional
    information is written out as an integral part of the transaction
    commit process.  Each transaction committed to the Ganymede data
    store causes an XML file to be written which contains the before
    and after state of all objects that were modified during the
    transaction and which the sync channel is configured to care
    about.  As soon as possible after a transaction is committed, an
    external build process is run which processes all unprocessed XML
    transaction files in chronological order.</p>

    <p><code class="type">Manual</code> sync channels are never
    scheduled.  The only purpose of a manual sync channel is to
    represent a named set of object and field types to be dumped when
    the <a href="../xml/xmlclient.html">xmlclient</a> <code
    class="filename">-dumpdata</code> command is given with the <code
    class="filename">sync=channel</code> option.  The output produced
    by the <code class="filename">xmlclient -dumpdata
    sync=channel -includeOid</code> command is identical to that generated by an
    equivalently configured automatic full state sync channel.</p>

    <p>More on this anon.</p>

    <p>A <code class="type">Sync Channel</code> object looks like
    this:</p>

    <center><img src="screenshots/sync_channel.png" class="screenshot"/></center>

    <p>and has the following fields:</p>

    <ul>
      <li><code class="type">Name</code> -- The unique name for this
      Sync Channel.</li>

      <li><code class="type">Sync Channel Type</code> -- Your choice
      among 'Manual', 'Automatic Full State', and 'Automatic
      Incremental'.</li>

      <li><code class="type">Sync Master Classname</code> -- Optional,
      the name of a Java class file in your Ganymede server's
      CLASSPATH that implements
      the <a href="../javadoc/arlut/csd/ganymede/server/SyncMaster.html">SyncMaster</a>
      interface.  A SyncMaster class is used to inject additional
      context into the XML files produced by a given Sync Channel.</li>

      <li><code class="type">Queue Directory</code> -- Path to the
      directory that the Ganymede server will write incremental
      synchronization files into.  Only meaningful in incremental Sync
      Channels.</li>

      <li><code class="type">Full State File</code> -- Fully specified
      path to the file to which that the Ganymede server will write
      full state synchronization files.  Only meaningful in full state
      Sync Channels.</li>

      <li><code class="type">Service Program</code> -- Path to the
      executable external program that will process the
      synchronization files.  Meaningful for both incremental and full
      state Sync Channels.</li>

      <li><code class="type">Sync Data</code> -- Aggregate field that
      contains a map of object and field types to the conditions under
      which they are (or are not) to be written to this Sync Channel.
      By editing this field, you control what types of objects and
      what fields thereunder will be written to this sync channel, and
      under what circumstances.</li>

      <li>
	<code class="type">Allow Plaintext Passwords</code> --
	Check-box controlling whether or not password plaintext is
	allowed to be written to this Sync Channel.

	<br/><br/>

	If this check-box is not selected, the Ganymede server will
	still permit stored password hashes to be written to the Sync
	Channel, but plaintext will be disallowed.  You might want to
	restrict plaintext passwords if you know that your Service
	Program doesn't need access to the plain text in order to
	synchronize passwords.

	<br/><br/>

	See the <a
	href="../xml/data.html#PASSWORD">&lt;password&gt;</a> element
	guide for more details on password hashing vs. plaintext.
      </li>
    </ul>

    <h3 id="sync_data">The Sync Data Field</h3>

    <p>You configure the data that will be synchronized to the Sync
    Channel by editing the <code class="type">Sync Data</code> field
    with the Ganymede client.  For each type of object defined on your
    Ganymede server, you will see a check-box that lets you choose
    whether or not that kind of object should ever be synchronized to
    the Sync Channel.</p>

    <p>If you open up the folder for a given object type, you will be
    able to select three options for every field: <b>Never</b>,
    <b>When Changed</b>, and <b>Always</b>.</p>

    <p>These three options control whether or not that field should be
    written and/or considered when deciding whether to write an object
    to the Sync Channel.  The interpretation of these fields is
    slightly different in the incremental and full state cases, as
    follows:</p>

    <table>
      <tr><th>Option</th><th>Manual / Full State</th><th>Incremental</th></tr>
      <tr>
        <td><b>Never</b></td>
        <td>This field will never be written.</td>
        <td>This field will never be written and it will never be
        considered when determining whether an object in a
        transaction should be written to the Sync Channel.</td>
      </tr>
      <tr>
        <td><b>When Changed</b></td>
        <td>This field will be written.</td>
        <td>This field be written only if it changed during the
        transaction. If this field is changed during a transaction,
        the object as a whole will be written to the Sync Channel at
        commit time.</td>
      </tr>
      <tr>
        <td><b>Always</b></td>
        <td>This field will be written.</td>
        <td>This field be written if any field in the object marked
        'When Changed' or 'Always' was changed during the
        transaction.  If this field is changed during a transaction,
        the object as a whole will be written to the Sync Channel at
        commit time.</td>
      </tr>
    </table>

    <p>The purpose of the <b>Always</b> option is intended to allow
    you to mark fields whose data must always be included when an
    object of that type is written to the Sync Channel.  If your
    service program will always need to know the contents of a user
    object's <code class="type">Username</code> field every time the
    object is changed (even if the Username itself did not change),
    you can configure your Sync Channel's <code class="type">Sync
    Data</code> to always include it with the <b>Always</b>
    option.</p>

    <p>For Full State and Manual Sync Channels, <b>Always</b> and
    <b>When Changed</b> are synonyms.  The difference between the two
    is only significant for Incremental Sync channels, where a <b>When
    Changed</b> field will only be written to a transaction record if
    it changed during the transaction.</p>

    <p>Here's an example of what you might see when you edit a <code
    class="type">Sync Data</code> field in a <code class="type">Sync
    Channel</code> object:</p>

    <center><img src="screenshots/sync_field_options.png" class="screenshot"/></center>

    <h2 id="xml_full_state">4. Full State Sync Channels</h2>

    <p>When a transaction is committed in Ganymede, the server
    examines every Full State Sync Channel registered in the server
    and determines whether the committed transaction contained any
    objects and fields that match up against the Sync Channel's <a
    href="#sync_data">Sync Data</a> field. If so, as soon thereafter
    as the GanymedeScheduler can manage (that is, as soon as any
    previous build on the Sync Channel has finished), a
    synchronization to the Sync Channel will be performed.</p>

    <p>As we have discussed, this synchronization is a two phase
    process.  The server executes a <a
    href="../javadoc/arlut/csd/ganymede/server/SyncRunner.html">SyncRunner</a>
    object associated with the Sync Channel, which locks the database
    against commits and writes out everything in the Ganymede Server
    which matches the Sync Channel's <code class="type">Sync
    Data</code> constraints to the defined <code class="type">Full
    State File</code>.  When the file is finished being written out,
    the database is unlocked to allow commits to take place and the
    Sync Channel's external <code class="type">Service Program</code>
    is run to process the synchronization data.</p>

    <p>Here's what a Full State Sync Channel looks like:</p>

    <center><img src="screenshots/full_sync_channel.png" class="screenshot"/></center>

    <h4 id="xml_full_state_service_program">Writing a Sync Channel Full State Service Program</h4>

    <p>The Sync Channel Full State Service Program is tasked with
    taking an XML file written by the Ganymede server which contains
    all objects and fields in the server which match an <b>Always</b>
    or <b>When Changed</b> specification in the Sync Channel's <a
    href="#sync_data">Sync Data</a> field.  The Service Program must
    read this file and then take whatever actions are required to
    bring the external target service into congruence with the data in
    the XML file.</p>

    <p>We don't know what sort of external target service you may find
    yourself wanting to support with a Full State Sync Channel, but we
    can guess at the sort of things your Service Program may need to
    do.  Creating records, deleting records, editing records, and
    possibly renaming or moving records.  Implementing the logic to
    interact with any given external service is necessarily a custom
    job, according to how unique the external service you're trying to
    support is.</p>

    <p>It's very simple to say what the Ganymede server will give your
    Service Program to help it along:</p>

    <p><i>Almost nothing</i>.</p>

    <p>Because of practical limitations on how well Java code can
    interact with the native operating system environment (UNIX-style
    systems, typically, for Ganymede), the Ganymede server doesn't try
    to set up any environment variables for your program.  It doesn't
    even try to ensure that your program is started in any specific
    working directory.  It certainly doesn't try to do any logging for
    your Service Program in any way.</p>

    <p>What it does give the Service Program is a single command line
    parameter, which provides the file path to the XML file written
    out by the Sync Channel's <a
    href="../javadoc/arlut/csd/ganymede/server/SyncRunner.html">SyncRunner</a>.
    </p>

    <p>The Service Program should start off by changing its working
    directory to a suitable location, setting any environment
    variables necessary (PATH or LD_LIBRARY_PATH included), and
    arranging for its own logging to the appropriate log mechanism.</p>

    <p>Once all that is done, it should read in the XML file and start
    to work.</p>

    <div class="note">
      <p>Here's a quick summary of things you should know when creating
      your Full State Service Program:</p>

      <ul>
        <li>The Ganymede server will not write to your service program's
        standard input stream.</li>

        <li>Anything your service program writes to its standard output or
        error streams will be completely ignored by Ganymede, and lost.
        You are responsible for making your service program log any error
        conditions to something other than standard error.</li>

        <li>Your service program should expect a single command line
        argument from Ganymede, that being the path to the full state XML
        file to be processed.</li>

        <li>Your service program should not expect to have any useful environment
        variables set by Ganymede.</li>

        <li>Your service program should not expect to have its current
        working directory set to anything useful or meaningful by
        Ganymede.</li>

        <li>Your service program should not terminate until the
        synchronization process is truly finished, and it is safe for the
        Ganymede server to begin a new external synchronization.</li>
      </ul>

      <p>That last point is critical to ensuring that the Ganymede
      server will not try and schedule multiple overlapping external
      builds.  Ganymede will wait for your service program to complete
      before processing the next full state synchronization to your Sync
      Channel.  This is what you want, so don't confuse the Ganymede
      server by having your service program try and run things in the
      background.</p>
    </div>

    <p>Here's an example of the sort of XML file that the Full State
    Service Program must be prepared to process:</p>

    <pre class="listing">&lt;ganymede major="1" minor="0"&gt;
  &lt;ganydata&gt;
    &lt;object type="User" id="jonabbey" oid="3:1143"&gt;
      &lt;Username&gt;jonabbey&lt;/Username&gt;
      &lt;UID&gt;6074&lt;/UID&gt;
      &lt;Password&gt;&lt;password plaintext="S00perSekret" crypt="zv16nogZ9eRP5" md5crypt="$1$bH3vxykP$dkmWhIdVuqC8Y1h0s7PQU1" lanman="8AF317306D28CA711D0DC6E\
72A9441BB" ntmd4="D3A6370C044FD34C6A487A6F5F53A6C1" ssha="{SSHA}cdHEG7iIMT2ZSHkJEf4fR62v/b23rnMO"/&gt;&lt;/Password&gt;
      &lt;Account_Category&gt;&lt;invid type="User_Category" id="normal" oid="279:5"/&gt;&lt;/Account_Category&gt;
      &lt;Full_Name&gt;Jonathan Abbey&lt;/Full_Name&gt;
      &lt;Badge&gt;x819&lt;/Badge&gt;
      &lt;Division&gt;ITS&lt;/Division&gt;
      &lt;Room&gt;S321&lt;/Room&gt;
      &lt;Office_Phone&gt;835-3199&lt;/Office_Phone&gt;
      &lt;Groups&gt;
        &lt;invid type="Group" id="omssys" oid="257:245"/&gt;
        &lt;invid type="Group" id="csdweb" oid="257:114"/&gt;
        &lt;invid type="Group" id="omrgen" oid="257:264"/&gt;
      &lt;/Groups&gt;
      &lt;Home_Group&gt;&lt;invid type="Group" id="omssys" oid="257:245"/&gt;&lt;/Home_Group&gt;
      &lt;Login_Shell&gt;/bin/tcsh&lt;/Login_Shell&gt;
      &lt;Home_Directory&gt;/home/jonabbey&lt;/Home_Directory&gt;
      &lt;Directory_Volume&gt;
      &lt;object type="Embedded_Automounter_Map_Entry" id="jonabbey/auto.home.default" oid="278:1257"&gt;
        &lt;Automounter_Map&gt;&lt;invid type="Automounter_Map" id="auto.home.default" oid="277:2"/&gt;&lt;/Automounter_Map&gt;
        &lt;NFS_Volume&gt;&lt;invid type="NFS_Volume" id="omg2" oid="276:636"/&gt;&lt;/NFS_Volume&gt;
      &lt;/object&gt;
      &lt;/Directory_Volume&gt;
      &lt;Email_Aliases&gt;
        &lt;string val="abbey"/&gt;
      &lt;/Email_Aliases&gt;
      &lt;Signature_Alias&gt;jonabbey&lt;/Signature_Alias&gt;
      &lt;Email_target&gt;
        &lt;string val="jonabbey@arlmail.arlut.utexas.edu"/&gt;
      &lt;/Email_target&gt;
    &lt;/object&gt;
  &lt;/ganydata&gt; 
&lt;/ganymede&gt;</pre>

    <p>Some of the details of the XML schema used are dependent on the
    specific Ganymede schema in on the Ganymede server.  In
    particular, the names of the field elements (and what sorts of
    data the field elements contain) are up to you when you define the
    Ganymede schema.</p>

    <p>Because whitespace is not allowed in element names, the field
    names you'll see in the XML file are processed with a simple <a
    href="../xml.html#underscore">spaces to underscores</a> encoding
    to make sure that field names cohere with proper XML specs.</p>

    <p>This format is basically identical to the output of an <a
    href="../xml/xmlclient.html">xmlclient</a> data object dump, as
    documented in the <a href="../xml/data.html">Ganymede XML
    &lt;ganydata&gt; Guide</a>.</p>

    <p>The only differences are that:</p>

    <ul>
      <li>The <a href="../xml/data.html#INVID">&lt;invid&gt;</a>
      elements always have the <b>oid</b> attribute, whereas <a
      href="../xml/xmlclient.html">xmlclient</a>'s output only includes
      this attribute when the <code>-includeOid</code> parameter is
      provided.</li>

      <li>The data that is dumped is filtered by the <a
      href="#sync_data">Sync Data</a> constraints specified in the
      Sync Channel.</li>
    </ul>

    <h2 id="xml_incrementals">5. Incremental Sync Channels</h2>

    <p>The general structure and timing of the Incremental Sync
    Channel system is both similar to and different from the Full
    State Sync Channel model.  Like the Full State Sync Channel model,
    synchronization is a two phase process.  In the first phase,
    synchronization data is written out using a standard XML file
    format that is generated for you by the Ganymede server.  In the
    second phase, an external service program is executed to process
    synchronization data in the XML output.</p>

    <p>The Incremental Sync Channel differs from the Full State Sync
    Channel in when the data is written out, and what that data looks
    like.</p>

    <p>In the Sync Channel Incremental model, the first step of
    writing out the synchronization data is done as an integral part
    of the transaction commit process.  A transaction is not
    considered persistently committed unless and until all Incremental
    Sync Channels have successfully written out their XML files
    describing everything that happened in the transaction relevant to
    the individual Sync Channel.</p>

    <p>The second step is scheduled for asynchronous execution with
    the Ganymede Scheduler at some later point in time.  Usually, this
    is carried out almost immediately after a transaction is
    committed.  If the Sync Channel is still working on a previous
    execution of the Service Program, however, the external process
    for step two will be delayed until the previous run is
    finished.</p>

    <p>At no point is the Ganymede server's database locked to prevent
    transaction commits.  This is very important for performance,
    because it means that no one has to wait for an Incremental Sync
    Channel's external service program to complete before committing
    additional changes to the Ganymede server.</p>

    <p>This does mean, though, that transactions can start to pile up
    in an Incremental Sync Channel's Queue Directory while an external
    synchronization is being carried out.</p>

    <p>To deal with this, Incremental Sync Channels are designed to
    function as message queues.  Transactions are written to the Queue
    Directory in order as they are committed.  When the external
    service program is run, the XML files are read and processed in
    the same order.  As each XML file is processed, a delta is
    calculated and sent to the target service.</p>

    <p>This gives us the efficiency (and the downsides) inherent to
    the incremental synchronization model <a
    href="#describing_incremental">discussed above</a>.</p>

    <h4 id="configuring_sync_incremental">Configuring Incremental Sync Channels</h4>

    <p>All that you need to do to configure an incremental Sync
    Channel in Ganymede is to create an <b>Automatic Incremental</b>
    <code class="type">Sync Channel</code> object in the Ganymede
    server.</p>

    <p>An incremental <code class="type">Sync Channel</code> object
    looks like this:</p>

    <center><img src="screenshots/sync_channel.png" class="screenshot"/></center>

    <h4 id="what_xml_incremental_writes">What The Sync Channel Incremental Model Writes Out</h4>

    <p>The Ganymede server writes one XML file to the Sync Channel
    synchronization directory for each relevant transaction that is
    committed to the Ganymede server.  Each transaction is given a
    simple integer filename, unadorned with any filename extension.
    The Ganymede server maintains a transaction count for every
    transaction committed after the Ganymede server is initialized,
    the first transaction committed being transaction zero.</p>

    <p>Each file that is written out looks like this:</p>

    <pre class="listing">&lt;transaction major_version="1" minor_version="1" channel="Mac Sync Channel" user="supergash" number="18" time="1111015745225"&gt;
  &lt;object_delta&gt;
    &lt;before&gt;
      &lt;object type="User" id="barkerr" oid="3:1175"&gt;
        &lt;Home_Phone&gt;512-555-3481&lt;/Home_Phone&gt;
        &lt;Domain&gt;&lt;invid type="LDAP_Domain" id="ARL_Mac" oid="284:4"/&gt;&lt;/Domain&gt;
      &lt;/object&gt;
    &lt;/before&gt;
    &lt;after&gt;
      &lt;object type="User" id="barkerr" oid="3:1175"&gt;
        &lt;Home_Phone&gt;512-555-3522&lt;/Home_Phone&gt;
        &lt;Domain&gt;&lt;invid type="LDAP_Domain" id="ARL_Mac" oid="284:4"/&gt;&lt;/Domain&gt;
      &lt;/object&gt;
    &lt;/after&gt;
  &lt;/object_delta&gt;
  &lt;context_objects&gt;
    &lt;object type="LDAP_Domain" id="ARL_Mac" oid="284:4"&gt;
      &lt;DN&gt;cn=arlut,cn=utexas,cn=edu&lt;/DN&gt;
    &lt;/object&gt;
  &lt;/context_objects&gt;
&lt;/transaction&gt;</pre>

    <p id="transaction_element">The attributes in the &lt;transaction&gt; element are as follows:</p>

    <div align="center">
      <table border="1">
	<tr><th>Attribute</th><th>Value</th></tr>
	<tr><td><b>major_version</b></td><td>A major version number
	for the Ganymede Sync Channel transaction format.</td></tr>
	<tr><td><b>minor_version</b></td><td>A minor version number
	for the Ganymede Sync Channel transaction format.</td></tr>
	<tr><td><b>channel</b></td><td>The name of the Sync Channel
	that generated this XML file.</td></tr>
	<tr><td><b>user</b></td><td>The name of the Ganymede user or
	admin that committed this transaction.</td></tr>
	<tr><td><b>number</b></td><td>Unique number for this
	transaction, the number of transactions committed by this
	Ganymede server prior to this one.  Also the filename of this
	file.</td></tr>
	<tr><td><b>time</b></td><td>Java time code marking the time
	this transaction was written.  Interpreted as the number of
	milliseconds since Midnight, January 1, 1970 UTC.</td></tr>
      </table>
    </div>

    <p>The <b>&lt;transaction&gt;</b> element contains a series of one
    or more <b>&lt;object_delta&gt;</b> elements, followed by an
    optional <b>&lt;context_objects&gt;</b> element, which we will
    discuss shortly.</p>

    <p>The <b>&lt;object_delta&gt;</b> elements record the actual
    changes made to an individual object in this transaction.  It
    contains a
    <b>&lt;before&gt;</b> element and an <b>&lt;after&gt;</b>
    element.</p>

    <p>The <b>&lt;before&gt;</b> and <b>&lt;after&gt;</b> elements may
    contain one <b>&lt;object&gt;</b> element each.  These
    <b>&lt;object&gt;</b> elements are identical to the <a
    href="../xml/data.html#OBJECT">&lt;object&gt;</a> elements as they
    are used with the <a
    href="../glossary.html#xmlclient">xmlclient</a>, except that the
    <code class="attribute">oid</code> attribute has been added.  The
    <code class="attribute">oid</code> attribute may be useful to your
    Sync Channel service program as a foreign key that does not change
    between the <b>&lt;before&gt;</b> and <b>&lt;after&gt;</b>
    elements, even if the object is renamed in the transaction.</p>

    <p class="note"><a href="../xml/data.html#INVID">&lt;invid&gt;</a>
    elements also have <code class="attribute">oid</code> attributes.
    Any cross-referencing you need to do in your service program you
    should do with these oids.</p>

    <p>The other big difference with the <b>&lt;object&gt;</b> elements in
    the Sync Channel XML output is that they will only include the
    fields that the <code class="type">Sync Channel</code> was
    configured to write.  This is where our friends <b>Always</b> and
    <b>When Changed</b> come into play.</p>

    <p class="note">There is yet a third difference, having to do with
    how embedded objects are handled.  In <a
    href="../glossary.html#xmlclient">xmlclient</a>'s normal output,
    embedded objects are embedded in place, while in Sync Channel
    output, embedded object trees are simply represented as flat lists
    of <a href="../xml/data.html#INVID">&lt;invid&gt;</b></a>
    elements.  This is pretty obscure, but if you're dealing with
    embedded objects in your Ganymede schema, you'll see what we
    mean.</p>

    <p>If a field did change during the transaction, its before state
    will be written in the <b>&lt;before&gt;</b> element, and its
    after state will be written in the <b>&lt;after&gt;</b> element.
    If a field was newly created during the transaction, the field
    will not appear in the <b>&lt;before&gt;</b> element but it will
    appear in the <b>&lt;after&gt;</b> element.  Likewise, if a field
    was deleted during the transaction, it will appear in the
    &lt;before&gt; element but not in the <b>&lt;after&gt;</b>
    element.</p>

    <p>If an object is created or destroyed in a transaction rather
    than merely edited, the <b>&lt;before&gt;</b> or
    <b>&lt;after&gt;</b> elements, respectively, will be empty.</p>

    <p>Note that in this example, we have the optional <b>&lt;context_objects&gt;</b> element
    after our &lt;object_delta&gt; elements.</p>

    <p>If you look at the <b>User</b> records in
    the <b>&lt;object_delta&gt;</b>, you'll see that the <b>Domain</b>
    field element is present, and contains
    an <a href="../xml/data.html#INVID">&lt;invid&gt;</b></a> pointer
    field element.  It is pointing to an <b>LDAP Domain</b> object.</p>

    <p>The <b>LDAP Domain</b> object is not included in
    an <b>&lt;object_delta&gt;</b> element because it was not modified
    by this transaction.  Still, in this case, the information in this
    other object is needed by the service program to locate the User
    object in the remote directory service.</p>

    <p>How did this extra, unmodified object get into this transaction
    file?  Who decided to create the <b>&lt;context_objects&gt;</b>
    element for us?</p>

    <p>The Sync
    Channel's <a href="../javadoc/arlut/csd/ganymede/server/SyncMaster.html">Sync
    Master</a> did.  It was programmed to know that the service
    program needed to know the <b>LDAP Domain</b>'s Distinguished Name
    (DN) in order to find the User account's counterpart in the target
    directory service.  Because that information was not included in
    the modified <b>User</b> object, the Sync Master had to add
    it.</p>

    <p>If this context information had been physically located inside
    the <b>User</b> object type, we wouldn't have needed to set up
    a <a href="../javadoc/arlut/csd/ganymede/server/SyncMaster.html">SyncMaster</a>
    for this Sync Channel.  The <b>DN</b> field would have been marked
    as <b>Always</b> in the <b>Sync Data</b> field, and the Sync
    Channel would have automatically included it whenever when changes
    made to this User.</p>

    <p>Because that information is held in a linked object instead,
    the <b>&lt;context_objects&gt;</b> section comes into play, along
    with the <b>Domain</b> link field which was marked as
    an <b>Always</b> field in the <b>Sync Data</b> for this
    channel.</p>

    <p>Here's an example of a user in the laboratory's Ganymede server
    being deleted by the expiration task:</p>

<pre class="listing">&lt;transaction major_version="1" minor_version="1" channel="Mac Sync Channel" user="expiration" number="21" time="1111730401435"&gt;
  &lt;object_delta&gt;
    &lt;before&gt;
      &lt;object type="User" id="raghu" oid="3:1657"&gt;
        &lt;Username&gt;raghu&lt;/Username&gt;
        &lt;UID&gt;3025&lt;/UID&gt;
        &lt;Global_UID&gt;11f3a6c0-a9cd-11d8-b6ba-080020fd6b07&lt;/Global_UID&gt;
        &lt;Account_Category&gt;&lt;invid type="User_Category" id="normal" oid="279:5"/&gt;&lt;/Account_Category&gt;
        &lt;Full_Name&gt;Raj Raghu&lt;/Full_Name&gt;
        &lt;Badge&gt;5917&lt;/Badge&gt;
        &lt;Division&gt;ASD&lt;/Division&gt;
        &lt;Room&gt;N347&lt;/Room&gt;
        &lt;Office_Phone&gt;3872&lt;/Office_Phone&gt;
        &lt;Groups&gt;
          &lt;invid type="Group" id="asrmas" oid="257:143"/&gt;
          &lt;invid type="Group" id="omssys" oid="257:851"/&gt;
        &lt;/Groups&gt;
        &lt;Home_Group&gt;&lt;invid type="Group" id="asrmas" oid="257:143"/&gt;&lt;/Home_Group&gt;
        &lt;Login_Shell&gt;/bin/bash&lt;/Login_Shell&gt;
        &lt;Home_Directory&gt;/home/raghu&lt;/Home_Directory&gt;
        &lt;Directory_Volume&gt;
          &lt;invid type="Embedded_Automounter_Map_Entry" id="Embedded Automounter Map Entry[1810]" oid="278:1810"/&gt;
        &lt;/Directory_Volume&gt;
        &lt;Signature_Alias&gt;raghu&lt;/Signature_Alias&gt;
        &lt;Email_target&gt;
          &lt;string val="raghu@arlmail.arlut.utexas.edu"/&gt;
        &lt;/Email_target&gt;
        &lt;Password_Expiration&gt;&lt;date val="Tue, 08 Mar 2005 00:00:01" timecode="1110261601003"/&gt;&lt;/Password_Expiration&gt;
        &lt;Owner_list&gt;
          &lt;invid type="Owner_Group" id="ATL" oid="0:9"/&gt;
        &lt;/Owner_list&gt;
      &lt;/object&gt;
    &lt;/before&gt;
    &lt;after/&gt;
  &lt;/object_delta&gt;
&lt;/transaction&gt;
</pre>

    <p>Notice that all fields that were contained in the object prior
    to the transaction commit and which match the <code
    class="type">Sync Data</code> constraints are included in the
    before state, while the after state is empty.  This is an
    ex-user.</p>

    <h4 id="xml_incremental_service_program">Writing a Sync Channel Incremental Service Program</h4>

    <p>Writing a Service Program for use with the Sync Channel
    Incremental Mode is generally rather more complicated than <a
    href="#xml_full_state_service_program">writing an external sync
    script for use with a Full State Service Program</a>.  In addition
    to parsing and processing the XML written out by the Ganymede
    server, your Service Program has to be able to cooperate with the
    Ganymede server in carrying out the message queuing protocol for
    the Incremental Sync Channel.</p>

    <p>Here are the rules for an Incremental Sync Channel Service
    Program:</p>

    <ul>
      <li>As with the Full State Service Program external sync
      scripts, your Service Program is on its own with regard to
      setting up environment variables, working directory,
      logging/output streams, and locating files.  Of particular note,
      your Service Program must know how to find its Queue Directory
      with no hints from the Ganymede server at runtime.</li>

      <li>The Ganymede server will run your Service Program with a
      single command line argument.  This will be the highest
      transaction number your Service Program is allowed to process
      during this run.  Any transactions with higher numbers that your
      Service Program may come across in the Sync Channel Queue
      Directory are not safe to operate on, as they may not be fully
      written or committed.  Even if they are fully written, they may
      later be withdrawn if the server runs into an I/O problem while
      writing XML to other configured Sync Channel Queue Directories.
      <b>Never, ever trust a transaction with a higher number than you
      are given on the command line.  Don't read them, don't look at
      them, just don't do it</b>.</li>

      <li>Your Service Program is required to process transactions in
      increasing numeric order.  <b>Be careful to use a numeric sort
      and not a textual sort when ordering your processing</b>.</li>

      <li>Your Service Program must process transactions.  This
      involves reading an XML transaction file from the Queue
      Directory, parsing and interpreting the XML record in terms of
      the Ganymede server schema, and performing the appropriate
      action on the target directory service to make the equivalent
      changes in the target service's schema.</li>

      <li>Your Service Program is responsible for removing
      successfully processed transactions from the Queue Directory.
      <b>Your Service Program must only remove a transaction from the
      Queue Directory when it is certain that the change has been
      properly synchronized into the target service</b>.  You may wish
      to move successfully committed transactions to another directory
      for record keeping (and the possibility of playback in the event
      of a rollback of your target service), or you may delete them
      from the Queue Directory entirely.  Your Service Program must
      not leave processed transactions in the Queue Directory.</li>

      <li>It is conceivable that your Service Progam may be
      interrupted or killed after it has completely processed a
      transaction and before it has cleared the transaction from the
      Queue Directory.  You must attempt to deal with this situation
      as cleanly as possible.  Ideally, your Service Program should be
      able to recognize that the target service is already compliant
      with the after state of a given transaction.  This should only
      ever happen with the first transaction your Service Program has
      to service in any run, as <b>your Service Program should never
      start processing a transaction before it has cleared the
      previous transaction from the Queue Directory</b>.</li>

      <li>If your Service Program encounters a transaction that it
      cannot process due to a transient error, it must stop processing
      transactions, and leave the failed transaction in the Queue
      Directory for processing by a later attempt.</li>

      <li>
	If your Service Program encounters a transaction that it
	cannot process due to a data mismatch with the target service,
	<b>you must attempt to notify a human to take a look at the
	problem</b>.  This may be through logging to a Service
	Program-specific log, by writing to a syslog service, by
	creating an SNMP trap, or by sending email.  Or all of the
	above, if you can.  Your Service Program must process no
	further transactions, and it must leave the problematic
	transaction in the Queue Directory for human examination.
	
	<br/><br/>
      
	This class of error should ideally never occur, if your
	Ganymede server schema and your Service Program and your
	target service are all properly compatible.
      </li>

      <li>If you can determine with confidence that certain classes of
      data mismatches are non-fatal and will not cause new problems to
      arise with future transactions, you may record a non-fatal error
      to your Service Program log, move the problematic transaction
      aside for human examination, and continue processing
      transactions.  You should be extraordinarily certain about your
      logic before doing this, however.</li>
    </ul>

    <p>As you can see, writing an Incremental Sync Channel's Service
    Program can be quite involved.  To make it easier on you, we have
    written a Python package, SyncUtils, which knows how to set up
    logging, how to parse Ganymede XML transaction files, and how to
    identify what objects and fields were created, edited, and
    deleted.  Writing synchronization code with SyncUtils is as easy
    as writing a callback Python function that takes data from the
    SyncUtils package and works with it from there.</p>

    <h2 id="xml_manual">6. The Sync Channel Manual Model</h2>

    <p>The Sync Channel Manual model is based on the <a
    href="#xml_full_state">Sync Channel Full State Model</a>.  Unlike
    any other synchronization systems supported by the Ganymede server
    the Sync Channel Manual model is not supported by the Ganymede
    server as an automated build system.</p>

    <p>Instead, the Sync Channel Manual model refers to the ability to
    use the <a href="../xml/xmlclient.html">xmlclient</a> to dump out
    a subset of the Ganymede datastore, using a <a
    href="#sync_channels">Sync Channel</a> object to constrain the
    object and field types dumped.  The idea is that, after dumping
    out your information using <a
    href="../xml/xmlclient.html">xmlclient</a>, you use a variant of
    the <a href="#xml_full_state_service_program">Sync Channel Full
    State Service Program</a> to synchronize the full state of your
    Ganymede data with your target directory service.</p>

    <p>The SyncUtils Python package that we have written knows how to
    read a Ganymede full state and/or manual XML dump, and can support
    you in doing manual full state synchronization.</p>

    <p>To generate a Sync Channel manual dump, you can run:</p>

    <div class="listing">xmlclient -dumpdata -includeOid "sync=Mac Sync Channel" &gt; user_full_state.xml</div>

    <p>The output of such a <code>xmlclient -dumpdata -includeOid</code> command
    is identical to that produced by the <a
    href="#xml_full_state">Sync Channel Full State Model</a>, and can
    be processed by any service program that is compatible with the
    requirements of the <a href="#xml_full_state_service_program">Sync
    Channel Full State Service Program</a>.</p>

    <p>Here is a screenshot of a Sync Channel configured for manual
    operation:</p>

    <center><img src="screenshots/manual_sync_channel.png" class="screenshot"/></center>

    <p>Note, however, that you can do this <code>xmlclient</code> dump
    trick with any Sync Channel that you have registered in your
    Ganymede server.  Actually configuring a Sync Channel as
    <code>Manual</code> is strictly optional, and would generally only
    be done when you know that you don't want the server ever to
    automatically generate an incremental or full state build for you
    using the Sync Channel.</p>

    <hr/>
    <address><a href="mailto:jonabbey@arlut.utexas.edu">Jonathan Abbey</a></address>
  </body>

</html>
